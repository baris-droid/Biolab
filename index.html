<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BioLab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        .ui-glass {
            background: rgba(15, 23, 42, 0.95);
            border-right: 1px solid rgba(56, 189, 248, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
        }
        
        /* Modal Stilleri */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .season-summer { color: #facc15; text-shadow: 0 0 10px rgba(250, 204, 21, 0.6); }
        .status-ok { color: #4ade80; }
        .status-panic { color: #fbbf24; font-weight: bold; animation: pulse 1s infinite; }
        .cannibal-active { animation: flash 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        #brainCanvas { image-rendering: pixelated; }
    </style>
</head>
<body>

    <!-- YARDIM MODALI (Gizli BaÅŸlar) -->
    <div id="help-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center modal-overlay">
        <div class="modal-content w-[600px] max-h-[80vh] rounded-xl p-6 text-gray-300 flex flex-col relative">
            <button id="btn-close-help" class="absolute top-4 right-4 text-gray-400 hover:text-white text-xl font-bold">&times;</button>
            
            <h2 class="text-2xl font-bold text-cyan-400 mb-4 border-b border-gray-700 pb-2">BioLab SimÃ¼lasyon Rehberi</h2>
            
            <div class="overflow-y-auto pr-2 space-y-4 text-sm leading-relaxed">
                <div>
                    <h3 class="text-white font-bold mb-1">ğŸ§¬ SimÃ¼lasyon Nedir?</h3>
                    <p class="text-gray-400">Bu, yapay sinir aÄŸlarÄ± ve genetik algoritmalarla Ã§alÄ±ÅŸan canlÄ± bir ekosistemdir. Her canlÄ±nÄ±n kendine ait bir beyni vardÄ±r ve Ã§evreyi Ã¶ÄŸrenerek hayatta kalmaya Ã§alÄ±ÅŸÄ±r.</p>
                </div>

                <div>
                    <h3 class="text-yellow-400 font-bold mb-1">ğŸ§  NÃ¶ro-Evrim & Zihin TaramasÄ±</h3>
                    <ul class="list-disc pl-4 text-gray-400 space-y-1">
                        <li><strong>Yapay Beyin:</strong> CanlÄ±lar (Girdi -> Gizli Katman -> Ã‡Ä±ktÄ±) mimarisine sahip bir sinir aÄŸÄ±yla karar verir.</li>
                        <li><strong>XAI (AÃ§Ä±klanabilir Zihin):</strong> Bir canlÄ±ya tÄ±kladÄ±ÄŸÄ±nÄ±zda saÄŸ altta beynini gÃ¶rebilirsiniz. <strong>Mavi</strong> baÄŸlar pozitif, <strong>Turuncu</strong> baÄŸlar negatif sinyalleri temsil eder.</li>
                        <li><strong>Genetik Renkler:</strong> CanlÄ±larÄ±n renk tonlarÄ±, beyinlerindeki genetik farklÄ±lÄ±klarÄ± (Fenotip) yansÄ±tÄ±r.</li>
                    </ul>
                </div>

                <div>
                    <h3 class="text-green-400 font-bold mb-1">âš–ï¸ Ekolojik Denge MekanizmalarÄ±</h3>
                    <ul class="list-disc pl-4 text-gray-400 space-y-1">
                        <li><strong>Histerezis DÃ¶ngÃ¼sÃ¼:</strong> PopÃ¼lasyon kritik seviyeye (5) dÃ¼ÅŸtÃ¼ÄŸÃ¼nde "Acil Durum" baÅŸlar ve sayÄ± gÃ¼venli seviyeye (20-50) Ã§Ä±kana kadar devam eder.</li>
                        <li><strong>Lazarus ProtokolÃ¼:</strong> Yok oluÅŸu engellemek iÃ§in sistem, tÃ¼kenen tÃ¼rleri otomatik olarak takviye eder.</li>
                        <li><strong>Biyolojik SÄ±nÄ±r (Telomer):</strong> Her canlÄ± mitoz bÃ¶lÃ¼nme ile en fazla <strong>3 yavru</strong> Ã¼retebilir. SonrasÄ±nda kÄ±sÄ±rlaÅŸÄ±r (Koyu halka ile gÃ¶sterilir).</li>
                    </ul>
                </div>

                <div>
                    <h3 class="text-red-400 font-bold mb-1">âš”ï¸ VahÅŸi DoÄŸa KurallarÄ±</h3>
                    <ul class="list-disc pl-4 text-gray-400 space-y-1">
                        <li><strong>YamyamlÄ±k:</strong> AvcÄ±lar Ã§ok aÃ§ kaldÄ±ÄŸÄ±nda ve av bulamadÄ±ÄŸÄ±nda kendi tÃ¼rlerini yiyebilir.</li>
                        <li><strong>Mevsimler:</strong> YazÄ±n yemek boldur. KÄ±ÅŸÄ±n kÄ±tlÄ±k baÅŸlar ve soÄŸuktan dolayÄ± enerji daha hÄ±zlÄ± tÃ¼kenir.</li>
                        <li><strong>Gece/GÃ¼ndÃ¼z:</strong> Geceleri gÃ¶rÃ¼ÅŸ mesafesi dÃ¼ÅŸer.</li>
                        <li><strong>AkÄ±llÄ± Gezinme:</strong> CanlÄ±lar rastgele titremek yerine "Reynolds Wandering" algoritmasÄ±yla akÄ±cÄ± bir ÅŸekilde etrafÄ± keÅŸfeder.</li>
                    </ul>
                </div>
            </div>
            
            <div class="mt-4 pt-4 border-t border-gray-700 text-center text-xs text-gray-500">
                Kapatmak iÃ§in Ã§arpÄ±ya basÄ±n veya dÄ±ÅŸarÄ± tÄ±klayÄ±n.
            </div>
        </div>
    </div>

    <!-- SOL PANEL -->
    <div class="fixed top-0 left-0 h-full w-[420px] ui-glass text-gray-300 flex flex-col p-3 z-20 text-xs">
        
        <div class="mb-3 border-b border-gray-700 pb-2 flex justify-between items-center">
            <h1 class="text-base font-bold text-cyan-400 flex items-center gap-2">
                <span>ğŸ§¬ BioLab v25</span>
                <span id="sys-status" class="text-[10px] status-ok">STABÄ°L</span>
            </h1>
            <!-- BÄ°LGÄ° BUTONU -->
            <button id="btn-help" class="text-gray-400 hover:text-white text-lg font-bold w-6 h-6 flex items-center justify-center rounded-full border border-gray-600 hover:bg-gray-700 transition">?</button>
        </div>

        <!-- Ã‡evre -->
        <div class="bg-gray-800/60 p-2 rounded border border-gray-700 mb-3">
            <div class="flex justify-between items-center mb-2">
                <div class="text-lg font-mono font-bold text-white" id="clock-display">06:00</div>
                <div class="font-bold tracking-widest uppercase season-summer" id="season-display">YAZ</div>
            </div>
            
            <div class="flex justify-between text-[10px] text-gray-400 mb-0.5">
                <span>GÃ¶rÃ¼ÅŸ (IÅŸÄ±k)</span> <span id="val-light">100%</span>
            </div>
            <div class="w-full bg-gray-900 h-1.5 rounded-full overflow-hidden mb-2">
                <div id="bar-light" class="h-full bg-yellow-400 transition-all duration-500" style="width: 100%"></div>
            </div>
            <div class="flex justify-between text-[10px] text-gray-400 mb-0.5">
                <span>GÄ±da (SÄ±caklÄ±k)</span> <span id="val-temp">20Â°C</span>
            </div>
            <div class="w-full bg-gray-900 h-1.5 rounded-full overflow-hidden">
                <div id="bar-temp" class="h-full bg-red-400 transition-all duration-500" style="width: 100%"></div>
            </div>
        </div>

        <!-- SayaÃ§lar -->
        <div class="grid grid-cols-2 gap-2 mb-3 text-center">
            <div class="bg-green-900/20 p-2 rounded border border-green-900/50 relative">
                <div class="text-green-400 font-bold">AV</div>
                <div id="count-prey" class="text-xl font-mono text-white">0</div>
                <div id="mode-prey" class="text-[9px] text-gray-400 mt-1">EÅŸeyli</div>
            </div>
            <div class="bg-red-900/20 p-2 rounded border border-red-900/50 relative">
                <div class="text-red-400 font-bold">AVCI</div>
                <div id="count-predator" class="text-xl font-mono text-white">0</div>
                <div id="mode-pred" class="text-[9px] text-gray-400 mt-1">EÅŸeyli</div>
                <div id="cannibal-alert" class="absolute top-1 right-1 text-[8px] text-red-500 font-bold hidden cannibal-active">YAMYAM</div>
            </div>
        </div>

        <!-- Grafik ve Beyin -->
        <div class="flex-grow flex flex-col min-h-0 mb-3">
            <div class="text-[10px] text-gray-500 mb-1">POPÃœLASYON GEÃ‡MÄ°ÅÄ°</div>
            <div class="bg-black/50 border border-gray-800 rounded h-24 w-full relative mb-2">
                <canvas id="graphCanvas" width="380" height="96"></canvas>
            </div>
            
            <div class="text-[10px] text-gray-500 mb-1 flex justify-between items-center">
                <span>BEYÄ°N TARAMASI: <span id="brain-owner" class="text-cyan-400 font-bold italic">-</span></span>
                <div class="text-right">
                    <div id="brain-state" class="text-[9px] font-bold text-gray-400">-</div>
                    <div id="mitosis-stat" class="text-[8px] text-gray-500 mt-0.5"></div>
                </div>
            </div>
            <div class="bg-black/90 border border-gray-700 rounded flex-grow relative overflow-hidden shadow-2xl">
                <div class="absolute inset-0 opacity-10" style="background-image: linear-gradient(#333 1px, transparent 1px), linear-gradient(90deg, #333 1px, transparent 1px); background-size: 10px 10px;"></div>
                <canvas id="brainCanvas" class="w-full h-full object-contain relative z-10"></canvas>
                <div id="brain-placeholder" class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 p-4 text-center z-20">
                    <span class="text-3xl mb-2 opacity-50">ğŸ”¬</span>
                    <span>Zihnini okumak iÃ§in<br>bir canlÄ±ya tÄ±kla</span>
                </div>
            </div>
        </div>

        <!-- Kontroller -->
        <div class="grid grid-cols-3 gap-2">
            <button id="btn-pause" class="bg-blue-600 hover:bg-blue-500 text-white py-1.5 rounded border border-blue-400 transition text-[10px] font-bold">
                â¸ï¸ Duraklat
            </button>
            <button id="btn-spawn" class="bg-gray-800 hover:bg-gray-700 text-gray-300 py-1.5 rounded border border-gray-600 transition text-[10px]">
                +10 Av
            </button>
            <button id="btn-reset" class="bg-red-900/30 hover:bg-red-800/50 text-red-300 py-1.5 rounded border border-red-800/50 transition text-[10px]">
                SÄ±fÄ±rla
            </button>
        </div>
    </div>

    <canvas id="worldCanvas"></canvas>

<script>
/* --- UTILS --- */
const Utils = {
    random: (min, max) => Math.random() * (max - min) + min,
    distSq: (x1, y1, x2, y2) => (x1-x2)**2 + (y1-y2)**2,
    angleDist: (a1, a2) => {
        let d = a1 - a2;
        while (d < -Math.PI) d += Math.PI * 2;
        while (d > Math.PI) d -= Math.PI * 2;
        return d;
    },
    mutate: (val, rate) => Math.random() < rate ? val + Utils.random(-0.2, 0.2) : val,
    activation: (x) => Math.tanh(x),
    
    hslToRgb: (h, s, l) => {
        let r, g, b;
        if(s == 0){ r = g = b = l; } else {
            const hue2rgb = (p, q, t) => {
                if(t < 0) t += 1; if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3);
        }
        return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    }
};

const COL = { POS: '#3b82f6', NEG: '#f97316', TXT: '#e2e8f0', BG: '#0f172a', GRID: '#1e293b' };

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { this.x *= n; this.y *= n; return this; }
    mag() { return Math.sqrt(this.x**2 + this.y**2); }
    normalize() { let m = this.mag(); if(m > 0) this.mult(1/m); return this; }
    limit(max) { if(this.mag() > max) { this.normalize(); this.mult(max); } return this; }
    heading() { return Math.atan2(this.y, this.x); }
    rotate(a) {
        const h = this.heading() + a; const m = this.mag();
        this.x = Math.cos(h) * m; this.y = Math.sin(h) * m;
        return this;
    }
    copy() { return new Vector(this.x, this.y); }
}

/* --- NEURAL NET --- */
class NeuralNetwork {
    constructor(i, h, o) {
        this.i=i; this.h=h; this.o=o;
        this.w1 = new Float32Array(i*h); this.w2 = new Float32Array(h*o);
        this.b1 = new Float32Array(h); this.b2 = new Float32Array(o);
        this.lIn = new Float32Array(i); this.lHid = new Float32Array(h); this.lOut = new Float32Array(o);
        this.initWeights();
    }
    initWeights() {
        const r = () => Utils.random(-1, 1);
        for(let k=0; k<this.w1.length; k++) this.w1[k]=r();
        for(let k=0; k<this.w2.length; k++) this.w2[k]=r();
        for(let k=0; k<this.b1.length; k++) this.b1[k]=r();
        for(let k=0; k<this.b2.length; k++) this.b2[k]=r();
    }
    predict(inputs) {
        this.lIn.set(inputs);
        for(let j=0; j<this.h; j++) {
            let sum = this.b1[j];
            for(let k=0; k<this.i; k++) sum += inputs[k] * this.w1[k*this.h+j];
            this.lHid[j] = Utils.activation(sum);
        }
        let output = [];
        for(let j=0; j<this.o; j++) {
            let sum = this.b2[j];
            for(let k=0; k<this.h; k++) sum += this.lHid[k] * this.w2[k*this.o+j];
            let val = Utils.activation(sum);
            this.lOut[j] = val;
            output.push(val);
        }
        return output;
    }
    copy(rate) {
        const c = new NeuralNetwork(this.i, this.h, this.o);
        const m = (s, d) => { for(let k=0; k<s.length; k++) d[k] = Utils.mutate(s[k], rate); };
        m(this.w1, c.w1); m(this.w2, c.w2); m(this.b1, c.b1); m(this.b2, c.b2);
        return c;
    }
    static crossover(a, b, rate) {
        const c = new NeuralNetwork(a.i, a.h, a.o);
        const mix = (arrA, arrB, t) => {
            for(let i=0; i<t.length; i++) {
                let g = Math.random() < 0.5 ? arrA[i] : arrB[i];
                t[i] = Utils.mutate(g, rate);
            }
        };
        mix(a.w1, b.w1, c.w1); mix(a.w2, b.w2, c.w2);
        mix(a.b1, b.b1, c.b1); mix(a.b2, b.b2, c.b2);
        return c;
    }
    getGenomeHash() {
        let sum = 0;
        for(let i=0; i<this.w1.length; i++) sum += this.w1[i];
        return Math.tanh(sum / 10); 
    }
}

/* --- ENTITIES --- */
const CFG = { width: window.innerWidth || 800, height: window.innerHeight || 600, mutationRate: 0.15 };

class Entity {
    constructor(x, y, color) {
        this.pos = new Vector(x, y);
        let angle = Math.random() * Math.PI * 2;
        this.vel = new Vector(Math.cos(angle), Math.sin(angle));
        this.acc = new Vector(0, 0);
        this.col = color; 
        this.dead = false;
        this.age = 0;
        this.maxAge = Utils.random(2500, 4500); 
        this.targetLine = null;
        this.wanderTheta = angle;
        this.isWandering = false; 
        this.shield = 300; 
        this.confidence = 0;
        this.mitosisCount = 0; 
    }

    updatePhysics() {
        if (this.shield > 0) this.shield--;
        this.vel.add(this.acc);
        this.vel.limit(this.maxSpeed);
        this.pos.add(this.vel);
        this.acc.mult(0);
        this.age++;
        
        if(this.pos.x < 0) this.pos.x = CFG.width;
        if(this.pos.x > CFG.width) this.pos.x = 0;
        if(this.pos.y < 0) this.pos.y = CFG.height;
        if(this.pos.y > CFG.height) this.pos.y = 0;
    }

    sensor(target, range, fov, lightLevel) {
        let effRange = range * (0.3 + 0.7 * lightLevel); 
        let d = Math.sqrt(Utils.distSq(this.pos.x, this.pos.y, target.x, target.y));
        if(d > effRange) return null;
        let angle = target.sub(this.pos).heading();
        let diff = Utils.angleDist(angle, this.vel.heading());
        if(Math.abs(diff) <= fov/2) return { dist: 1 - (d / effRange), angle: diff / Math.PI };
        return null;
    }

    applyWander() {
        this.isWandering = true;
        this.confidence = 0.1; 
        this.wanderTheta += Utils.random(-0.3, 0.3);
        let circlePos = this.vel.copy(); circlePos.normalize(); circlePos.mult(60);
        let h = this.vel.heading();
        let offset = new Vector(25 * Math.cos(this.wanderTheta + h), 25 * Math.sin(this.wanderTheta + h));
        let target = circlePos.add(offset); target.limit(0.3);
        this.acc.add(target);
        let forward = new Vector(Math.cos(h), Math.sin(h)); forward.mult(0.3);
        this.acc.add(forward);
    }
    
    getState() {
        if (this.dead) return "Ã–lÃ¼";
        if (this.shield > 0) return "Yeni DoÄŸan";
        if (this.energy < 30) return "AÃ§lÄ±ktan Ã–lÃ¼yor";
        if (this.isWandering) return "Geziniyor";
        if (this.targetLine) return "Kilitlendi";
        return "DolaÅŸÄ±yor";
    }
}

class Prey extends Entity {
    constructor(x, y, brain) {
        super(x, y, '#4ade80'); 
        this.energy = 100; 
        this.maxSpeed = 3.5;
        this.brain = brain || new NeuralNetwork(5, 6, 2);
        this.reproThresh = 120;
        this.reproCost = 50;

        let geneHash = this.brain.getGenomeHash(); 
        let hue = 120 + (geneHash * 40); 
        this.col = Utils.hslToRgb(hue/360, 0.7, 0.5);
    }
    think(foods, predators, lightLevel) {
        let fIn={a:0, d:0}, pIn={a:0, d:0};
        let minF=-1;
        let hasTarget = false;

        for(let f of foods) {
            let s = this.sensor(f.pos, 140, Math.PI/1.4, lightLevel);
            if(s && s.dist > minF) { minF=s.dist; fIn={a:s.angle, d:s.dist}; hasTarget=true; }
        }
        for(let p of predators) {
            let s = this.sensor(p.pos, 140, Math.PI, lightLevel);
            if(s && s.dist > pIn.d) { pIn={a:s.angle, d:s.dist}; hasTarget=true; }
        }
        this.targetLine = minF > -1 ? foods.find(f => this.sensor(f.pos, 140, Math.PI/1.4, lightLevel)?.dist === minF)?.pos : null;

        if (!hasTarget) this.applyWander();
        else {
            this.isWandering = false;
            let out = this.brain.predict([fIn.a, fIn.d, pIn.a, pIn.d, this.energy/150]);
            this.confidence = (Math.abs(out[0]) + Math.abs(out[1])) / 2;
            this.vel.rotate(out[0] * 0.5);
            let thrust = (out[1] + 1) / 2;
            let f = new Vector(Math.cos(this.vel.heading()), Math.sin(this.vel.heading()));
            f.mult(thrust * 0.5); this.acc.add(f);
        }

        if (this.shield <= 0) this.energy -= 0.1 + (this.vel.mag() * 0.05);
        else this.energy -= 0.02;

        if ((this.energy <= 0 || this.age > this.maxAge) && this.shield <= 0) this.dead = true;
    }
    draw(ctx, isSelected) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(this.vel.heading());
        
        if (this.mitosisCount >= 3) {
             ctx.strokeStyle = '#333'; ctx.lineWidth = 3; 
             ctx.beginPath(); ctx.arc(0,0, 8, 0, Math.PI*2); ctx.stroke();
        }

        if(this.shield > 0) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
            ctx.beginPath(); ctx.arc(0,0, 12, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
        }
        if(isSelected && this.isWandering) {
             ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0,0, 20, 0, Math.PI*2); ctx.stroke();
        }
        if(isSelected && !this.isWandering) {
             ctx.fillStyle = 'rgba(74, 222, 128, 0.2)'; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 140, -Math.PI/2.8, Math.PI/2.8); ctx.fill();
        }
        ctx.fillStyle = isSelected ? '#fff' : this.col;
        ctx.beginPath(); ctx.moveTo(8,0); ctx.lineTo(-5,-5); ctx.lineTo(-5,5); ctx.fill();
        ctx.restore();
    }
}

class Predator extends Entity {
    constructor(x, y, brain) {
        super(x, y, '#f87171'); 
        this.energy = 220; 
        this.maxSpeed = 4.2;
        this.brain = brain || new NeuralNetwork(3, 6, 2);
        this.cooldown = 0; 
        this.isCannibal = false; 

        let geneHash = this.brain.getGenomeHash(); 
        let hue = 10 + (geneHash * 30); 
        if(hue < 0) hue += 360;
        this.col = Utils.hslToRgb(hue/360, 0.8, 0.6);
    }
    
    think(preys, predators, lightLevel) {
        let pIn={a:0, d:0};
        let closest=null, minD=-1;
        let nightVision = Math.max(lightLevel, 0.4); 
        let hasTarget = false;

        let preyScarcity = preys.length < 10 || (preys.length / (predators.length || 1) < 2);
        let starving = this.energy < 80; 
        this.isCannibal = (starving && preyScarcity);
        let targets = this.isCannibal ? predators : preys;

        for(let t of targets) {
            if(t === this) continue; 
            let s = this.sensor(t.pos, 250, Math.PI/1.5, nightVision);
            if(s && s.dist > minD) { minD=s.dist; closest=t; pIn={a:s.angle, d:s.dist}; hasTarget=true; }
        }
        this.targetLine = closest ? closest.pos : null;

        if (!hasTarget) this.applyWander();
        else {
            this.isWandering = false;
            let out = this.brain.predict([pIn.a, pIn.d, this.energy/200]);
            this.confidence = (Math.abs(out[0]) + Math.abs(out[1])) / 2;
            this.vel.rotate(out[0] * 0.4);
            let thrust = (out[1] + 1) / 2;
            let f = new Vector(Math.cos(this.vel.heading()), Math.sin(this.vel.heading()));
            f.mult(thrust * 0.8); this.acc.add(f);
        }

        if (this.shield <= 0) this.energy -= 0.08 + (this.vel.mag() * 0.05);
        else this.energy -= 0.02;
        
        if(this.cooldown > 0) this.cooldown--;
        if ((this.energy <= 0 || this.age > this.maxAge) && this.shield <= 0) this.dead = true;
    }

    draw(ctx, isSelected) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(this.vel.heading());
        
        if (this.mitosisCount >= 3) {
             ctx.strokeStyle = '#333'; ctx.lineWidth = 3; 
             ctx.beginPath(); ctx.arc(0,0, 10, 0, Math.PI*2); ctx.stroke();
        }

        if(this.shield > 0) {
            ctx.strokeStyle = '#ffaaaa'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
            ctx.beginPath(); ctx.arc(0,0, 14, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
        }
        if(this.isCannibal) { ctx.shadowBlur = 10; ctx.shadowColor = '#ef4444'; }
        
        if(isSelected && this.isWandering) {
             ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0,0, 20, 0, Math.PI*2); ctx.stroke();
        }
        if(isSelected && !this.isWandering) {
            ctx.fillStyle = this.isCannibal ? 'rgba(255,0,0,0.2)' : 'rgba(255,0,0,0.1)';
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, 220, -Math.PI/3, Math.PI/3); ctx.fill();
        }
        ctx.fillStyle = isSelected ? '#fff' : (this.isCannibal ? '#7f1d1d' : this.col);
        ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-6,-7); ctx.lineTo(-3,0); ctx.lineTo(-6,7); ctx.fill();
        ctx.shadowBlur = 0; ctx.restore();
    }
    getState() {
        let base = super.getState();
        if (base === "Kilitlendi") return this.isCannibal ? "Yamyam AvÄ±nda" : "Av GÃ¶rdÃ¼";
        return base;
    }
}

class Food {
    constructor(x, y) { this.pos = new Vector(x, y); this.size = 3; }
    draw(ctx) { ctx.fillStyle='#fbbf24'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.fill(); }
}

/* --- WORLD --- */
class World {
    constructor() {
        this.c = document.getElementById('worldCanvas');
        this.ctx = this.c.getContext('2d');
        this.bc = document.getElementById('brainCanvas').getContext('2d');
        this.gc = document.getElementById('graphCanvas').getContext('2d');
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.preys = []; this.preds = []; this.foods = [];
        this.hist = { prey: [], pred: [] };
        this.selected = null; this.dragged = null;
        this.paused = false; 
        this.frame = 0;
        
        this.preyEmergency = false; 
        this.predEmergency = false; 
        
        this.time = 0;
        this.dayLength = 3000; 
        this.yearLength = 12000; 

        this.setupInput();
        this.init();
        this.loop();
    }

    resize() {
        let w = window.innerWidth; let h = window.innerHeight;
        if (w < 100) w = 800; if (h < 100) h = 600;
        this.c.width = w; this.c.height = h; CFG.width = w; CFG.height = h;
        let br = document.getElementById('brainCanvas').getBoundingClientRect();
        this.bc.canvas.width = br.width; this.bc.canvas.height = br.height;
    }

    init() {
        this.time = 0; 
        this.preys = []; this.preds = []; this.foods = [];
        this.hist = { prey: [], pred: [] };
        this.preyEmergency = false; this.predEmergency = false;
        
        let areaFactor = (CFG.width * CFG.height) / (1000 * 800); 
        let startPrey = Math.floor(50 * Math.min(1.5, Math.max(0.5, areaFactor)));
        let startPred = Math.floor(8 * Math.min(1.5, Math.max(0.5, areaFactor)));
        let startFood = Math.floor(100 * Math.min(1.5, Math.max(0.5, areaFactor)));

        for(let i=0; i<startPrey; i++) this.preys.push(new Prey(Math.random()*CFG.width, Math.random()*CFG.height));
        for(let i=0; i<startPred; i++) this.preds.push(new Predator(Math.random()*CFG.width, Math.random()*CFG.height));
        for(let i=0; i<startFood; i++) this.foods.push(new Food(Math.random()*CFG.width, Math.random()*CFG.height));
    }

    setupInput() {
        this.c.addEventListener('mousedown', e => {
            let mx = e.clientX, my = e.clientY;
            let closest = null, min = 2500;
            [...this.preys, ...this.preds].forEach(a => {
                let d = Utils.distSq(mx, my, a.pos.x, a.pos.y);
                if(d < min) { min = d; closest = a; }
            });
            this.selected = closest; this.dragged = closest;
            
            let ph = document.getElementById('brain-placeholder');
            let bo = document.getElementById('brain-owner');
            let bs = document.getElementById('brain-state');
            let ms = document.getElementById('mitosis-stat');
            
            if(closest) {
                ph.style.display = 'none';
                let type = closest instanceof Predator ? (closest.isCannibal ? "AvcÄ± (YAMYAM)" : "AvcÄ± (Normal)") : "Av (Prey)";
                bo.innerText = type;
                bs.innerText = closest.getState();
                
                let limitText = closest.mitosisCount >= 3 ? " (DOLDU)" : "";
                ms.innerText = `Mitoz: ${closest.mitosisCount}/3${limitText}`;
                ms.className = closest.mitosisCount >= 3 ? "text-[8px] text-red-400 font-bold mt-0.5" : "text-[8px] text-gray-500 mt-0.5";
            } else {
                ph.style.display = 'flex'; bo.innerText = "-"; bs.innerText = "-"; ms.innerText = "";
                this.bc.clearRect(0,0,this.bc.canvas.width, this.bc.canvas.height);
            }
        });
        this.c.addEventListener('mousemove', e => {
            if(this.dragged && !this.dragged.dead) {
                this.dragged.pos.x = e.clientX; this.dragged.pos.y = e.clientY;
                this.dragged.vel.mult(0);
            }
        });
        this.c.addEventListener('mouseup', () => this.dragged = null);
        
        document.getElementById('btn-pause').onclick = () => {
            this.paused = !this.paused;
            const btn = document.getElementById('btn-pause');
            if(this.paused) {
                btn.innerHTML = "â–¶ï¸ Devam Et";
                btn.className = "bg-green-600 hover:bg-green-500 text-white py-1.5 rounded border border-green-400 transition text-[10px] font-bold";
            } else {
                btn.innerHTML = "â¸ï¸ Duraklat";
                btn.className = "bg-blue-600 hover:bg-blue-500 text-white py-1.5 rounded border border-blue-400 transition text-[10px] font-bold";
            }
        };

        document.getElementById('btn-spawn').onclick = () => {
             for(let i=0; i<10; i++) this.preys.push(new Prey(Math.random()*CFG.width, Math.random()*CFG.height));
        };
        document.getElementById('btn-reset').onclick = () => this.init();

        // Modal Events
        const modal = document.getElementById('help-modal');
        const btnHelp = document.getElementById('btn-help');
        const btnClose = document.getElementById('btn-close-help');

        btnHelp.onclick = () => modal.classList.remove('hidden');
        btnClose.onclick = () => modal.classList.add('hidden');
        modal.onclick = (e) => { if(e.target === modal) modal.classList.add('hidden'); };
    }

    updateEnvironment() {
        this.time++;
        let dayPhase = (Math.sin(this.time * (Math.PI*2/this.dayLength)) + 1) / 2;
        this.light = 0.1 + (dayPhase * 0.9);
        let yearPhase = Math.cos(this.time * (Math.PI*2/this.yearLength));
        this.temp = (yearPhase + 1) / 2;

        let h = Math.floor(dayPhase*24), m = Math.floor((dayPhase*24%1)*60);
        document.getElementById('clock-display').innerText = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
        
        let sElem = document.getElementById('season-display');
        if(yearPhase > 0.3) { sElem.innerText = "YAZ"; sElem.className = "season-summer font-bold tracking-widest"; }
        else if(yearPhase < -0.3) { sElem.innerText = "KIÅ"; sElem.className = "text-blue-400 font-bold tracking-widest"; }
        else { sElem.innerText = "BAHAR"; sElem.className = "text-gray-400 font-bold tracking-widest"; }

        document.getElementById('val-light').innerText = Math.floor(this.light*100) + "%";
        document.getElementById('bar-light').style.width = (this.light*100) + "%";
        document.getElementById('val-temp').innerText = Math.floor(-5 + this.temp * 35) + "Â°C";
        document.getElementById('bar-temp').style.width = (this.temp*100) + "%";
    }

    update() {
        this.updateEnvironment();

        if (this.preyEmergency) { if (this.preys.length >= 50) this.preyEmergency = false; } 
        else { if (this.preys.length <= 5) this.preyEmergency = true; }
        if (this.predEmergency) { if (this.preds.length >= 15) this.predEmergency = false; } 
        else { if (this.preds.length <= 5) this.predEmergency = true; }

        let cannibalActive = this.preds.some(p => p.isCannibal);
        let sysStatus = document.getElementById('sys-status');
        let canStatus = document.getElementById('cannibal-alert');
        let modePrey = document.getElementById('mode-prey');
        let modePred = document.getElementById('mode-pred');

        canStatus.style.display = cannibalActive ? 'block' : 'none';
        if(this.preyEmergency || this.predEmergency) {
            sysStatus.innerText = "BÃœYÃœME DESTEÄÄ°"; sysStatus.className = "text-[10px] status-panic";
        } else {
            sysStatus.innerText = "STABÄ°L"; sysStatus.className = "text-[10px] status-ok";
        }
        modePrey.innerText = this.preyEmergency ? "MÄ°TOZ (Hedef: 50)" : "EÅŸeyli";
        modePrey.className = this.preyEmergency ? "text-[9px] status-panic mt-1" : "text-[9px] text-gray-400 mt-1";
        modePred.innerText = this.predEmergency ? "MÄ°TOZ (Hedef: 15)" : "EÅŸeyli";
        modePred.className = this.predEmergency ? "text-[9px] status-panic mt-1" : "text-[9px] text-gray-400 mt-1";

        let foodCap = 150;
        let spawnChance = (1 - (this.foods.length / foodCap)) * 0.1 * (0.2 + 0.8 * this.temp);
        if(this.preyEmergency) spawnChance = 0.3; 
        if(Math.random() < spawnChance) this.foods.push(new Food(Math.random()*CFG.width, Math.random()*CFG.height));

        for(let i=this.preys.length-1; i>=0; i--) {
            let p = this.preys[i];
            p.think(this.foods, this.preds, this.light);
            p.updatePhysics();

            for(let j=this.foods.length-1; j>=0; j--) {
                if(Utils.distSq(p.pos.x, p.pos.y, this.foods[j].pos.x, this.foods[j].pos.y) < 100) {
                    p.energy += 30; this.foods.splice(j, 1);
                }
            }
            
            let thresh = this.preyEmergency ? 50 : 120;
            let cost = this.preyEmergency ? 15 : 50;

            if(p.energy > thresh && this.preys.length < 300) {
                if(this.preyEmergency) {
                    if (p.mitosisCount < 3) {
                        p.energy -= cost;
                        p.mitosisCount++; 
                        this.preys.push(new Prey(p.pos.x, p.pos.y, p.brain.copy(CFG.mutationRate)));
                    }
                } else {
                    let mate = null;
                    for(let other of this.preys) {
                        if(other !== p && other.energy > thresh && Utils.distSq(p.pos.x, p.pos.y, other.pos.x, other.pos.y) < 900) {
                            mate = other; break;
                        }
                    }
                    if(mate) {
                        p.energy -= cost; mate.energy -= cost; 
                        let childBrain = NeuralNetwork.crossover(p.brain, mate.brain, CFG.mutationRate);
                        this.preys.push(new Prey(p.pos.x, p.pos.y, childBrain));
                    }
                }
            }
            if(p.dead) { this.foods.push(new Food(p.pos.x, p.pos.y)); this.preys.splice(i, 1); }
        }

        for(let i=this.preds.length-1; i>=0; i--) {
            let p = this.preds[i];
            p.think(this.preys, this.preds, this.light);
            p.updatePhysics();

            for(let j=this.preys.length-1; j>=0; j--) {
                if(!this.preys[j].shield > 0 && Utils.distSq(p.pos.x, p.pos.y, this.preys[j].pos.x, this.preys[j].pos.y) < 100) {
                    let gain = this.preys[j].energy * 0.9 + 20;
                    p.energy += gain; this.preys[j].dead = true;
                }
            }
            
            if(p.isCannibal) {
                for(let j=this.preds.length-1; j>=0; j--) {
                    let other = this.preds[j];
                    if(p !== other && !other.dead && !other.shield > 0) { 
                        if(Utils.distSq(p.pos.x, p.pos.y, other.pos.x, other.pos.y) < 100) {
                             p.energy += 120; other.dead = true;
                        }
                    }
                }
            }

            let thresh = this.predEmergency ? 80 : 300;
            let cost = this.predEmergency ? 30 : 150;

            if(p.energy > thresh && p.cooldown <= 0) {
                if(this.predEmergency) {
                    if (p.mitosisCount < 3) {
                        p.energy -= cost;
                        p.mitosisCount++;
                        this.preds.push(new Predator(p.pos.x, p.pos.y, p.brain.copy(CFG.mutationRate)));
                        p.cooldown = 30;
                    }
                } else {
                    let mate = null;
                    for(let other of this.preds) {
                        if(other !== p && other.energy > thresh && Utils.distSq(p.pos.x, p.pos.y, other.pos.x, other.pos.y) < 900) {
                            mate = other; break;
                        }
                    }
                    if(mate) {
                        p.energy -= cost; mate.energy -= cost;
                        let childBrain = NeuralNetwork.crossover(p.brain, mate.brain, CFG.mutationRate);
                        this.preds.push(new Predator(p.pos.x, p.pos.y, childBrain));
                        p.cooldown = 60; mate.cooldown = 60;
                    }
                }
            }
            if(p.dead) { this.foods.push(new Food(p.pos.x, p.pos.y)); this.preds.splice(i, 1); }
        }

        if(this.preys.length < 2) this.preys.push(new Prey(Math.random()*CFG.width, Math.random()*CFG.height));
        if(this.preds.length < 1 && this.preys.length >= 20) {
            this.preds.push(new Predator(Math.random()*CFG.width, Math.random()*CFG.height));
        }

        document.getElementById('count-prey').innerText = this.preys.length;
        document.getElementById('count-predator').innerText = this.preds.length;
        
        if(this.selected && !this.selected.dead) {
            document.getElementById('brain-state').innerText = this.selected.getState();
            let ms = document.getElementById('mitosis-stat');
            let limitText = this.selected.mitosisCount >= 3 ? " (DOLDU)" : "";
            ms.innerText = `Mitoz: ${this.selected.mitosisCount}/3${limitText}`;
            ms.className = this.selected.mitosisCount >= 3 ? "text-[8px] text-red-400 font-bold mt-0.5" : "text-[8px] text-gray-500 mt-0.5";
        } else if (this.selected && this.selected.dead) {
            this.selected = null;
            document.getElementById('brain-placeholder').style.display = 'flex';
            document.getElementById('brain-owner').innerText = "-";
            document.getElementById('brain-state').innerText = "-";
            document.getElementById('mitosis-stat').innerText = "";
            this.bc.clearRect(0,0,this.bc.canvas.width, this.bc.canvas.height);
        }
    }

    drawBrain(agent) {
        const ctx = this.bc; 
        const w = ctx.canvas.width; 
        const h = ctx.canvas.height;
        ctx.clearRect(0,0,w,h);
        
        if(!agent || agent.dead) return;
        const b = agent.brain;
        
        const padX = 45; 
        const getX = (c) => {
            if (c === 0) return padX;
            if (c === 1) return w / 2;
            return w - padX;
        };

        const inputLabels = (agent instanceof Predator) 
            ? ["Hedef AÃ§Ä±", "Hedef M.", "Enerji"] 
            : ["Besin AÃ§Ä±", "Besin M.", "AvcÄ± AÃ§Ä±", "AvcÄ± M.", "Enerji"];
        const outputLabels = ["DÃ¶nÃ¼ÅŸ", "HÄ±z"];
        
        let scanPos = (this.frame % 200) / 200 * w;
        let grad = ctx.createLinearGradient(scanPos, 0, scanPos+20, 0);
        grad.addColorStop(0, 'rgba(6, 182, 212, 0)');
        grad.addColorStop(0.5, 'rgba(6, 182, 212, 0.1)');
        grad.addColorStop(1, 'rgba(6, 182, 212, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);

        let maxIdx = -1;
        let maxVal = -1;
        for(let i=0; i<b.lIn.length; i++) {
            if(Math.abs(b.lIn[i]) > maxVal) {
                maxVal = Math.abs(b.lIn[i]);
                maxIdx = i;
            }
        }

        const drawSynapses = (wArr, c1, c2, l1, l2) => {
            const x1 = getX(l1), x2 = getX(l2);
            const s1 = h/(c1+1), s2 = h/(c2+1); 
            for(let i=0; i<c1; i++) for(let j=0; j<c2; j++) {
                let val = wArr[i*c2+j]; let act = Math.abs(l1===0 ? b.lIn[i] : b.lHid[i]);
                if(Math.abs(val) * act > 0.05) {
                    ctx.beginPath(); ctx.moveTo(x1, s1*(i+1)); ctx.lineTo(x2, s2*(j+1));
                    ctx.strokeStyle = val > 0 ? `rgba(59, 130, 246, ${Math.abs(val)*act})` : `rgba(249, 115, 22, ${Math.abs(val)*act})`;
                    ctx.lineWidth = Math.abs(val)*2*act + 0.5; 
                    ctx.stroke();
                }
            }
        };
        drawSynapses(b.w1, b.i, b.h, 0, 1); drawSynapses(b.w2, b.h, b.o, 1, 2);

        const drawNodes = (vals, col, count, labels, isHidden) => {
            const x = getX(col);
            const s = h/(count+1);
            ctx.font = "10px sans-serif"; ctx.textBaseline = "middle";
            for(let i=0; i<count; i++) {
                let v = vals[i];
                
                if(col === 0 && i === maxIdx && maxVal > 0.5) {
                    ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.strokeRect(x - 6, s*(i+1) - 6, 12, 12);
                    ctx.shadowBlur = 0; ctx.lineWidth = 0.5;
                }

                ctx.beginPath(); ctx.arc(x, s*(i+1), 5, 0, Math.PI*2);
                ctx.fillStyle = v > 0 ? COL.POS : COL.NEG;
                ctx.fill(); ctx.strokeStyle = '#fff'; ctx.stroke();

                if(labels) {
                    let barW = 15 * Math.abs(v);
                    let barX = col===0 ? x + 10 : x - 10 - barW;
                    ctx.fillStyle = v > 0 ? COL.POS : COL.NEG;
                    ctx.fillRect(barX, s*(i+1)+8, barW, 3);
                }

                if(labels) {
                    ctx.fillStyle = COL.TXT;
                    if(col === 0) { 
                        ctx.textAlign = "right"; ctx.fillText(labels[i], x - 12, s*(i+1));
                        ctx.fillStyle = v>0?COL.POS:COL.NEG; ctx.fillText(v.toFixed(2), x-12, s*(i+1)+10);
                    } else if (col === 2) { 
                        ctx.textAlign = "left"; ctx.fillText(labels[i], x + 12, s*(i+1));
                        ctx.fillStyle = v>0?COL.POS:COL.NEG; ctx.fillText(v.toFixed(2), x+12, s*(i+1)+10);
                    }
                } else if (isHidden) {
                    ctx.fillStyle = '#64748b'; ctx.textAlign = "center";
                    ctx.fillText("Ä°ÅŸlemci", x, s*(i+1)-12); 
                    ctx.fillStyle = v>0?COL.POS:COL.NEG; ctx.fillText(v.toFixed(1), x, s*(i+1)+10);
                }
            }
        };
        drawNodes(b.lIn, 0, b.i, inputLabels, false); 
        drawNodes(b.lHid, 1, b.h, null, true); 
        drawNodes(b.lOut, 2, b.o, outputLabels, false);
    }

    drawGraph() {
        const ctx = this.gc; const w = ctx.canvas.width, h = ctx.canvas.height;
        this.hist.prey.push(this.preys.length);
        this.hist.pred.push(this.preds.length * 5); 
        if(this.hist.prey.length > w) { this.hist.prey.shift(); this.hist.pred.shift(); }
        ctx.clearRect(0,0,w,h);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
        const drawLine = (data, color) => {
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
            for(let i=0; i<data.length; i++) {
                let y = h - (data[i] / 200 * h); y = Math.max(0, Math.min(h, y)); 
                i===0 ? ctx.moveTo(i, y) : ctx.lineTo(i, y);
            }
            ctx.stroke();
        };
        drawLine(this.hist.prey, '#4ade80'); drawLine(this.hist.pred, '#f87171'); 
    }

    loop() {
        this.frame++;
        if (!this.paused) {
            this.update();
        }
        this.ctx.fillStyle = '#0f172a'; this.ctx.fillRect(0, 0, CFG.width, CFG.height);
        this.foods.forEach(f => f.draw(this.ctx));
        this.preys.forEach(p => p.draw(this.ctx, p === this.selected));
        this.preds.forEach(p => p.draw(this.ctx, p === this.selected));
        let darkness = (1 - this.light) * 0.85;
        if(darkness > 0.05) { this.ctx.fillStyle = `rgba(0, 0, 0, ${darkness})`; this.ctx.fillRect(0, 0, CFG.width, CFG.height); }
        this.drawGraph();
        if(this.selected) this.drawBrain(this.selected);
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => new World();
</script>
</body>
</html>
